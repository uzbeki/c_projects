ポインタのポインタをやってみましょう。
処理の効率等は無視して、勉強としてやります。
現状オセロプラグラムについて、ボードはグローバルに宣言された二次元配列になっています。
board[8][8]

これをあえてポインタでアクセスすることを考えてみましょう。
ex: 一次元配列の場合・・・
int aaa[8] = {1,2,3,4,5,6,7,8};
上記は
int *bbb = aaa;
int ccc = *(bbb+3);
"output:ccc=4"
 で表せる。
 
アドレスがどのように取られているか理解できると処理することができると思います。
難しいですが、考えてみてください。

上記普通にやるとただのポインタ処理で終わります。

ポインタのポインタにするにはどうすれば良いのか？
これはちょっと難しいです。。。
int board[8][8] = {
  {  1,  2,  3,  4,  5,  6,  7,  8},
  {11,12,13,14,15,16,17,18},
  {21,22,23,24,25,26,27,28},
  {31,32,33,34,35,36,37,38},
  {41,42,43,44,45,46,47,48},
  {51,52,53,54,55,56,57,58},
  {61,62,63,64,65,66,67,68},
  {71,72,73,74,75,76,77,78},
};
 
だったとして・・・
#define SIZE_MAX 8
int var = 3; //(0～7)
int hor = 4; //(0～7)
int bbb = *(board+ (SIZE_MAX  * var) + hor);
 
"outbut:bbb=35"
これがポインタアクセス。
 
ダブルポインタはどう表す？
ん？

int bbb = *(board[var] + hor);
こうじゃないとアクセスできないかも？・・・